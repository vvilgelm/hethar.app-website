<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>hethar — presence breach</title>
<meta name="description" content="Hethar — presence that lives with you. Not an assistant. A second you." />

<!-- SEO & Social -->
<link rel="canonical" href="https://hethar.app/" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hethar.app/" />
<meta property="og:title" content="hethar — presence breach" />
<meta property="og:description" content="Not an assistant. A second presence that lives with you." />
<meta property="og:image" content="https://hethar.app/assets/opengraph/og.jpg" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:url" content="https://hethar.app/" />
<meta name="twitter:title" content="hethar — presence breach" />
<meta name="twitter:description" content="Not an assistant. A second presence that lives with you." />
<meta name="twitter:image" content="https://hethar.app/assets/opengraph/og.jpg" />

<!-- Favicons -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png">

<!-- Security Headers (CSP) -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://plausible.io; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://plausible.io https://ipapi.co; font-src 'self'; frame-src 'none'; object-src 'none';">

<!-- Preload critical font (when you add it) -->
<!-- <link rel="preload" href="/assets/fonts/your-font.woff2" as="font" type="font/woff2" crossorigin> -->

<style>
  /* PRESENCE BREACH — minimal, high-contrast, cinematic */
  :root{
    --bg:#000; --fg:#e8e8e8; --muted:#9aa0a6; --accent:#00ff7f; 
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    --ease: cubic-bezier(.22,.61,.36,1);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;overflow-x:hidden;}
  *{box-sizing:border-box}
  
  /* Skip intro button (accessibility) */
  .skip-intro{
    position:fixed;top:20px;right:20px;z-index:200;padding:8px 12px;border-radius:8px;
    background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);
    color:var(--muted);font-size:12px;font-family:var(--mono);cursor:pointer;
    transition:all .18s var(--ease);
  }
  .skip-intro:hover,.skip-intro:focus{background:rgba(255,255,255,0.1);color:var(--fg);outline:2px solid var(--accent);outline-offset:2px;}
  
  /* Scroll hint indicator */
  .scroll-hint{
    position:fixed;bottom:40px;left:50%;transform:translateX(-50%);z-index:100;
    display:flex;flex-direction:column;align-items:center;gap:8px;
    opacity:0;transition:opacity .4s var(--ease);pointer-events:none;
  }
  .scroll-hint.visible{opacity:1}
  .scroll-hint-text{
    font-family:var(--mono);font-size:12px;color:var(--muted);letter-spacing:0.05em;
  }
  .scroll-hint-icon{
    font-size:24px;color:var(--accent);animation:bounce 2s ease-in-out infinite;
  }
  @keyframes bounce{0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)}}
  
  /* Screen counter */
  .screen-counter{
    position:fixed;bottom:20px;right:20px;z-index:100;
    font-family:var(--mono);font-size:11px;color:var(--muted);
    background:rgba(0,0,0,0.6);backdrop-filter:blur(8px);
    padding:6px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);
  }
  
  .full{height:100vh;width:100vw;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
  .center-col{display:flex;flex-direction:column;gap:14px;align-items:center;max-width:1100px;padding:24px;text-align:center}
  .cursor{display:inline-block;width:10px;height:26px;background:var(--fg);vertical-align:middle;animation:blink 1s steps(2) infinite}
  @keyframes blink{50%{opacity:0}}
  .console{font-family:var(--mono);font-size:20px;letter-spacing:0.02em;line-height:1.6}
  .muted{color:var(--muted);font-size:14px}
  .ghost-green{color:#00ff7f}
  
  /* Matrix trail canvas */
  #matrixCanvas{position:fixed;inset:0;pointer-events:none;opacity:0;z-index:50;transition:opacity 0.8s ease-out}
  
  /* Memory residue canvas - DISABLED to prevent green tint */
  #residueCanvas{position:fixed;inset:0;pointer-events:none;opacity:0;z-index:2;display:none}
  
  /* Shadow cursor (predictive companion) */
  #shadowCursor{
    position:fixed;pointer-events:none;width:12px;height:12px;border-radius:50%;
    background:rgba(255,255,255,.18);transform:translate(-50%,-50%);
    mix-blend-mode:screen;z-index:9999;transition:opacity .2s;
    box-shadow:0 0 12px rgba(255,255,255,0.3);
  }
  #shadowCursor::after{
    content:'';position:absolute;inset:-4px;border-radius:50%;
    border:1px solid rgba(255,255,255,0.1);animation:pulse 2s ease-in-out infinite;
  }
  @keyframes pulse{0%,100%{transform:scale(1);opacity:0.3} 50%{transform:scale(1.4);opacity:0}}
  
  /* Breach animation overlay - subtle flash, doesn't block matrix */
  /* Breach element removed - not needed */
  
  /* Dossier screens */
  .dossier{height:100vh;width:100vw;display:flex;align-items:center;justify-content:center;position:relative;z-index:40;scroll-snap-align:start}
  .card{max-width:920px;padding:48px 36px;border-radius:6px;text-align:left}
  .line{font-family:var(--mono);font-size:36px;line-height:1.2;font-weight:700;letter-spacing:-0.02em}
  .line.muted{font-size:18px;color:var(--muted);font-weight:400}
  
  /* Dossier container with snap scrolling */
  #dossierContainer{
    scroll-snap-type:y mandatory;
    overflow-y:scroll;
    height:100vh;
    scroll-behavior:smooth;
  }
  
  /* Whispers */
  .whisper{
    position:fixed;left:28px;bottom:28px;padding:10px 14px;border-radius:10px;
    background:rgba(10,10,10,0.85);backdrop-filter:blur(8px);
    color:var(--muted);font-family:var(--mono);font-size:13px;
    opacity:0;transform:translateY(6px);transition:opacity .22s var(--ease),transform .22s var(--ease);
    z-index:60;max-width:420px;
    border:1px solid rgba(255,255,255,0.06);
  }
  .whisper.on{opacity:1;transform:translateY(0)}
  
  /* Temporal rewind UI */
  #rewindUI{
    position:fixed;right:20px;top:50%;transform:translateY(-50%);
    width:60px;height:400px;background:rgba(10,10,10,0.9);
    backdrop-filter:blur(8px);border-radius:12px;
    border:1px solid rgba(255,255,255,0.08);
    padding:20px 12px;display:none;flex-direction:column;align-items:center;
    z-index:100;
  }
  #rewindUI.on{display:flex}
  #rewindSlider{
    width:4px;height:100%;background:rgba(255,255,255,0.1);
    border-radius:4px;position:relative;cursor:pointer;
  }
  #rewindHandle{
    position:absolute;left:50%;transform:translateX(-50%);
    width:16px;height:16px;background:var(--accent);border-radius:50%;
    cursor:grab;transition:transform .1s;
  }
  #rewindHandle:active{cursor:grabbing;transform:translateX(-50%) scale(1.2)}
  
  /* Final CTA */
  .cta-wrap{display:flex;gap:16px;align-items:center;justify-content:center;margin-top:18px}
  .btn{
    padding:12px 24px;border-radius:999px;border:1px solid rgba(255,255,255,0.1);
    background:transparent;color:var(--fg);cursor:pointer;font-family:var(--mono);
    font-size:16px;transition:all .18s var(--ease);
  }
  .btn:hover,.btn:focus{background:rgba(255,255,255,0.05);outline:2px solid var(--accent);outline-offset:2px}
  .btn.primary{background:var(--fg);color:var(--bg);border-color:transparent;font-weight:700}
  .btn.primary:hover{background:var(--accent);color:var(--bg)}
  
  /* Input modal */
  .modal{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    z-index:120;background:rgba(0,0,0,0.85);backdrop-filter:blur(12px);
    opacity:0;pointer-events:none;transition:opacity .18s ease}
  .modal.on{opacity:1;pointer-events:auto}
  .modal .box{
    background:#0b0b0b;border:1px solid rgba(255,255,255,0.08);
    padding:32px;border-radius:16px;max-width:560px;width:92%;
    box-shadow:0 8px 32px rgba(0,0,0,0.8);
  }
  input[type="text"], input[type="email"]{
    width:100%;padding:14px 16px;border-radius:8px;
    border:1px solid rgba(255,255,255,0.1);background:#050505;
    color:var(--fg);font-family:var(--mono);font-size:15px;
    transition:all .18s;
  }
  input:focus{outline:2px solid var(--accent);outline-offset:2px;border-color:var(--accent)}
  label{display:block;margin-bottom:8px;color:var(--muted);font-size:13px;font-family:var(--mono)}
  
  /* Proximity permission card */
  #proximityCard{
    position:fixed;bottom:28px;right:28px;padding:16px 20px;
    background:rgba(10,10,10,0.95);backdrop-filter:blur(12px);
    border-radius:12px;border:1px solid rgba(255,255,255,0.08);
    max-width:360px;z-index:80;
    opacity:0;transform:translateY(12px);
    transition:opacity .3s var(--ease),transform .3s var(--ease);
  }
  #proximityCard.on{opacity:1;transform:translateY(0)}
  .geo-btn{
    padding:8px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);
    background:transparent;color:var(--fg);font-family:var(--mono);
    font-size:13px;cursor:pointer;transition:all .18s;margin-right:8px;
  }
  .geo-btn.primary{background:var(--accent);color:var(--bg);border:none;font-weight:600}
  .geo-btn:hover{background:rgba(255,255,255,0.08)}
  .geo-btn.primary:hover{background:#00d66f}
  
  /* Reduced motion */
  @media (prefers-reduced-motion: reduce){
    .cursor{animation:none}
    #matrixCanvas,#residueCanvas,#shadowCursor{display:none}
    *{animation:none !important;transition-duration:0.01ms !important}
  }
  
  /* Mobile optimizations */
  @media (max-width:720px){
    .line{font-size:24px}
    .console{font-size:16px}
    .whisper{left:16px;bottom:16px;max-width:calc(100vw - 32px);font-size:12px}
    #proximityCard{right:16px;bottom:16px;max-width:calc(100vw - 32px)}
    .btn{padding:10px 18px;font-size:14px}
    #rewindUI{display:none !important} /* hide on mobile */
  }
  
  /* Safe area for notched devices */
  @supports(padding:max(0px)){
    .whisper{bottom:max(28px, env(safe-area-inset-bottom))}
    #proximityCard{bottom:max(28px, env(safe-area-inset-bottom))}
  }
  
  /* Pause presence toggle */
  #pauseToggle{
    position:fixed;top:20px;left:20px;z-index:200;
    padding:8px 12px;border-radius:8px;
    background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);
    color:var(--muted);font-size:11px;font-family:var(--mono);
    cursor:pointer;transition:all .18s;
  }
  #pauseToggle:hover{background:rgba(255,255,255,0.1);color:var(--fg)}
  #pauseToggle.paused{background:rgba(255,100,100,0.2);color:#ff6b6b;border-color:#ff6b6b}
</style>

<!-- External feature modules -->
<script src="/js/ab-test.js"></script>
<script src="/js/copy-rails.js"></script>
<script src="/js/time-variants.js"></script>
<script src="/js/dossier-glints.js"></script>
<script src="/js/hover-pov.js"></script>
<script src="/js/webgl-shader.js"></script>
<script src="/js/handshake.js"></script>
<script src="/js/heatmap.js"></script>
<script src="/js/copy-generator.js"></script>
<script src="/js/legal-banner.js"></script>

<!-- Analytics -->
<script defer data-domain="hethar.app" src="https://plausible.io/js/script.js"></script>

</head>
<body>
  <!-- Accessibility: Skip intro -->
  <button id="skipIntro" class="skip-intro" aria-label="Skip introduction">skip intro</button>
  
  <!-- Pause presence toggle -->
  <button id="pauseToggle" aria-label="Pause presence features">presence: on</button>
  
  <!-- Scroll indicator -->
  <div id="scrollHint" class="scroll-hint">
    <div class="scroll-hint-text">scroll or press ↓</div>
    <div class="scroll-hint-icon">⌄</div>
  </div>
  
  <!-- Screen counter -->
  <div id="screenCounter" class="screen-counter" style="display:none">
    <span id="currentScreen">1</span> / <span id="totalScreens">14</span>
  </div>
  
  <!-- Canvas layers -->
  <canvas id="matrixCanvas" aria-hidden="true"></canvas>
  
  <!-- Residue canvas and shadow cursor REMOVED to eliminate green tint -->
  <!-- <canvas id="residueCanvas" aria-hidden="true"></canvas> -->
  <!-- <div id="shadowCursor" aria-hidden="true" style="display:none"></div> -->
  
  <!-- Temporal rewind UI -->
  <div id="rewindUI" role="region" aria-label="Temporal rewind">
    <div style="font-size:10px;color:var(--muted);font-family:var(--mono);margin-bottom:12px;text-align:center">REWIND</div>
    <div id="rewindSlider">
      <div id="rewindHandle"></div>
    </div>
    <div style="font-size:10px;color:var(--muted);font-family:var(--mono);margin-top:12px">press ESC</div>
  </div>
  
  <!-- Initial console full-screen -->
  <main id="stage" class="full" aria-live="polite">
    <div id="consoleWrap" class="center-col" style="z-index:50">
      <div class="console" id="consoleText" aria-live="polite"></div>
      <div id="consoleCursor" class="cursor" style="margin-top:6px;display:none"></div>
    </div>
  </main>

  <!-- Breach overlay removed - not needed -->

  <!-- Dossier screens container -->
  <div id="dossierContainer" style="display:none"></div>

  <!-- Whisper -->
  <div id="whisper" class="whisper" role="status" aria-live="polite"></div>

  <!-- Footer with privacy link -->
  <footer style="position:fixed;bottom:12px;right:12px;z-index:50;font-size:11px;opacity:0.4;transition:opacity 0.2s">
    <a href="/privacy.html" style="color:#9aa0a6;text-decoration:none;font-family:ui-monospace,monospace" 
       onmouseenter="this.style.opacity='1'" onmouseleave="this.style.opacity='0.6'">privacy</a>
  </footer>

  <!-- Proximity permission card -->
  <div id="proximityCard" role="dialog" aria-labelledby="geoTitle">
    <div id="geoTitle" style="font-family:var(--mono);font-size:14px;margin-bottom:10px;color:var(--fg)">small request</div>
    <div class="muted" style="font-size:13px;margin-bottom:16px">let me sense your neighbourhood. used to make this feel… you.</div>
    <div>
      <button id="geoAllow" class="geo-btn primary">allow</button>
      <button id="geoSkip" class="geo-btn">skip</button>
    </div>
  </div>

  <!-- Contact modal -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-hidden="true">
    <div class="box">
      <div style="margin-bottom:16px">
        <div id="modalTitle" style="font-family:var(--mono);font-weight:700;font-size:20px;margin-bottom:8px">where can i find you?</div>
        <div class="muted" style="font-size:14px">email or phone. only used to reach you if you said yes.</div>
      </div>
      <form id="contactForm">
        <label for="contactInput">contact</label>
        <input id="contactInput" name="contact" type="text" placeholder="you@example.com or +1 415 555 0123" autocomplete="email tel" required />
        <div style="display:flex;gap:10px;margin-top:18px;justify-content:flex-end">
          <button type="button" id="modalCancel" class="btn">not yet</button>
          <button type="submit" class="btn primary">send</button>
        </div>
      </form>
    </div>
  </div>

<script>
// PRESENCE BREACH — Full implementation
// Features: Console breach, Shadow cursor, Memory residue, Temporal rewind, Behavior whispers, Geo proximity

'use strict';

/* ============= CONFIG & STATE ============= */
const CONFIG = {
  apiEndpoint: '/api/contact',
  skipIntroKey: 'hethar_skip_intro',
  lastVisitKey: 'hethar_last_visit',
  geoAskedKey: 'hethar_geo_asked',
  pausedKey: 'hethar_paused',
  sessionWhisperKey: 'hethar_session_whisper',
  residueKey: 'hethar_residue'
};

const STATE = {
  paused: localStorage.getItem(CONFIG.pausedKey) === '1',
  skipIntro: localStorage.getItem(CONFIG.skipIntroKey) === '1',
  geoAsked: localStorage.getItem(CONFIG.geoAskedKey) === '1',
  sessionWhisperShown: sessionStorage.getItem(CONFIG.sessionWhisperKey) === '1',
  currentDossier: 0,
  isLocked: false,
  recording: [], // temporal rewind recording
  rewindMode: false
};

/* ============= UTILITIES ============= */
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
const rand = (arr)=> arr[Math.floor(Math.random()*arr.length)];
function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* ============= CITY INFERENCE ============= */
function inferCity() {
  const tz = (Intl && Intl.DateTimeFormat) ? Intl.DateTimeFormat().resolvedOptions().timeZone || '' : '';
  const map = [
    {match:/America\/Los_Angeles|PST|Pacific/, city:'SAN FRANCISCO NODE'},
    {match:/America\/New_York|EST|Eastern/, city:'NYC NODE'},
    {match:/Europe\/London|GMT/, city:'LONDON NODE'},
    {match:/Asia\/Tokyo/, city:'TOKYO NODE'},
    {match:/Europe\/Berlin/, city:'BERLIN NODE'},
    {match:/Europe\/Paris/, city:'PARIS NODE'},
    {match:/America\/Chicago|Central/, city:'CHICAGO NODE'}
  ];
  for (const m of map){
    if (m.match.test(tz)) return m.city;
  }
  if (tz && tz.includes('/')) return tz.split('/')[1].toUpperCase().replace('_',' ') + ' NODE';
  return 'NEARBY NODE';
}

/* ============= TYPING EFFECT ============= */
async function typeText(el, text, speed=40, opts={cursor:true}) {
  el.textContent = '';
  if (opts.cursor) showCursor(true);
  for (let i=0;i<text.length;i++){
    el.textContent += text[i];
    await sleep(speed + Math.random()*10);
  }
  if (opts.cursor) showCursor(false);
}

function showCursor(on){
  const c = document.getElementById('consoleCursor');
  if(!c) return;
  c.style.display = on ? 'inline-block' : 'none';
}

/* ============= MATRIX CANVAS ============= */
const matrixCanvas = document.getElementById('matrixCanvas');
const matrixCtx = matrixCanvas.getContext('2d');
let matrixRunning = false;

function fitCanvas(canvas){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
fitCanvas(matrixCanvas);
addEventListener('resize', ()=>fitCanvas(matrixCanvas));

function startMatrix() {
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    console.log('[Matrix] ✗ Blocked by prefers-reduced-motion');
    return;
  }
  if (STATE.paused) {
    console.log('[Matrix] ✗ Blocked by pause state');
    return;
  }
  
  console.log('[Matrix] ✓ Starting matrix animation...');
  matrixRunning = true;
  const cols = Math.floor(matrixCanvas.width / 14);
  const drops = Array.from({length:cols}).map(()=>Math.random()*-100);
  
  console.log('[Matrix] Canvas size:', matrixCanvas.width, 'x', matrixCanvas.height);
  console.log('[Matrix] Columns:', cols);
  
  (function draw(){
    if(!matrixRunning) return;
    matrixCtx.fillStyle = 'rgba(0,0,0,0.05)';
    matrixCtx.fillRect(0,0,matrixCanvas.width,matrixCanvas.height);
    matrixCtx.fillStyle = '#00ff7f';
    matrixCtx.font = '13px monospace';
    for (let i=0;i<drops.length;i++){
      const x = i * 14;
      const y = drops[i] * 14;
      const text = String.fromCharCode(33 + Math.random()*94);
      matrixCtx.fillText(text, x, y);
      if (y > matrixCanvas.height && Math.random() > 0.975) drops[i]=0;
      drops[i]++;
    }
    requestAnimationFrame(draw);
  })();
}

function stopMatrix(){ 
  matrixRunning=false; 
  matrixCtx.clearRect(0,0,matrixCanvas.width,matrixCanvas.height);
  matrixCanvas.style.opacity = '0';
}

function dimMatrix(opacity = 0.04){
  matrixCanvas.style.opacity = opacity;
}

/* ============= MEMORY RESIDUE CANVAS ============= */
// REMOVED - residue canvas deleted from DOM to eliminate green tint
// const residueCanvas = document.getElementById('residueCanvas');
// const residueCtx = residueCanvas.getContext('2d');
// fitCanvas(residueCanvas);
// addEventListener('resize', ()=>fitCanvas(residueCanvas));

const pathBuffer = [];
let lastPathTime = Date.now();

function recordPath(x, y){
  if (STATE.paused) return;
  pathBuffer.push({x, y, t:Date.now()});
  // Keep last 5 seconds
  const cutoff = Date.now() - 5000;
  while (pathBuffer.length && pathBuffer[0].t < cutoff) pathBuffer.shift();
}

function drawResidue(){
  // DISABLED - causes green tint accumulation
  return;
}

window.addEventListener('pointermove', e=>{
  recordPath(e.clientX, e.clientY);
  recordEvent('move', {x:e.clientX, y:e.clientY});
}, {passive:true});

// Residue drawing DISABLED to prevent green tint
// requestAnimationFrame(drawResidue);

/* ============= SHADOW CURSOR (Predictive) ============= */
// REMOVED - shadow cursor deleted from DOM to eliminate green tint
// const shadowCursor = document.getElementById('shadowCursor');
let mouse = {x:0, y:0, vx:0, vy:0, ts:Date.now()};

window.addEventListener('pointermove', e=>{
  const now = Date.now();
  const dt = Math.max(6, now - mouse.ts);
  mouse.vx = (e.clientX - mouse.x)/dt;
  mouse.vy = (e.clientY - mouse.y)/dt;
  mouse.x = e.clientX; 
  mouse.y = e.clientY; 
  mouse.ts = now;
}, {passive:true});

function perlinNoise(t){ 
  return (Math.sin(t*0.0023)+Math.sin(t*0.0071)*0.5)*0.5; 
}

function tickShadow(){
  if (STATE.paused || window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    shadowCursor.style.display = 'none';
    requestAnimationFrame(tickShadow);
    return;
  }
  
  shadowCursor.style.display = 'block';
  
  // Project forward
  const lead = 140 + (30 * Math.random());
  const px = mouse.x + mouse.vx * lead;
  const py = mouse.y + mouse.vy * lead;
  
  // Human noise
  const jitter = perlinNoise(Date.now()) * 8;
  const tx = px + jitter;
  const ty = py + jitter;
  
  // Easing lag
  const current = shadowCursor.getBoundingClientRect();
  const cx = current.left + current.width/2;
  const cy = current.top + current.height/2;
  const nx = cx + (tx - cx) * 0.18;
  const ny = cy + (ty - cy) * 0.18;
  
  shadowCursor.style.left = nx + 'px';
  shadowCursor.style.top = ny + 'px';
  
  requestAnimationFrame(tickShadow);
}
tickShadow();

/* ============= TEMPORAL REWIND ============= */
function recordEvent(type, data){
  if (STATE.paused) return;
  STATE.recording.push({type, data, t:Date.now()});
  // Keep last 3 minutes
  const cutoff = Date.now() - 180000;
  while (STATE.recording.length && STATE.recording[0].t < cutoff) STATE.recording.shift();
}

window.addEventListener('keydown', e=>{
  recordEvent('key', {key:e.key});
  
  // ESC = toggle rewind mode
  if (e.key === 'Escape'){
    if (!STATE.rewindMode && document.getElementById('dossierContainer').style.display === 'block'){
      STATE.rewindMode = true;
      document.getElementById('rewindUI').classList.add('on');
      trackEvent('rewind_open');
    } else if (STATE.rewindMode) {
      STATE.rewindMode = false;
      document.getElementById('rewindUI').classList.remove('on');
      trackEvent('rewind_close');
    }
  }
  
  // Space = toggle pause
  if (e.key === ' ' || e.code === 'Space'){
    e.preventDefault();
    document.getElementById('pauseToggle').click();
  }
  
  // Konami code: ↑ ↑ ↓ ↓ ← → ← → B A
  const konamiCode = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','b','a'];
  if (!window.konamiProgress) window.konamiProgress = 0;
  if (e.key === konamiCode[window.konamiProgress]) {
    window.konamiProgress++;
    if (window.konamiProgress === konamiCode.length) {
      showFloatingFlash('you found it. now what?');
      trackEvent('konami_code');
      window.konamiProgress = 0;
    }
  } else {
    window.konamiProgress = 0;
  }
  
  // Screenshot mode: Cmd+Shift+S
  if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 's'){
    e.preventDefault();
    const elementsToHide = [
      document.getElementById('pauseToggle'),
      document.getElementById('skipIntro'),
      document.getElementById('scrollHint'),
      document.getElementById('screenCounter')
    ];
    elementsToHide.forEach(el => {
      if(el) el.style.display = el.style.display === 'none' ? '' : 'none';
    });
    showWhisper(elementsToHide[0].style.display === 'none' ? 'screenshot mode' : 'UI restored');
    trackEvent('screenshot_mode');
  }
  
  // R = also toggle rewind (legacy)
  if (e.key === 'r' || e.key === 'R'){
    if (!STATE.rewindMode && document.getElementById('dossierContainer').style.display === 'block'){
      STATE.rewindMode = true;
      document.getElementById('rewindUI').classList.add('on');
      trackEvent('rewind_open');
    }
  }
});

// Rewind slider interaction
let rewindDragging = false;
const rewindHandle = document.getElementById('rewindHandle');
const rewindSlider = document.getElementById('rewindSlider');

rewindHandle.addEventListener('mousedown', ()=> rewindDragging = true);
document.addEventListener('mouseup', ()=> rewindDragging = false);
document.addEventListener('mousemove', e=>{
  if (!rewindDragging) return;
  const rect = rewindSlider.getBoundingClientRect();
  const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
  const pct = y / rect.height;
  rewindHandle.style.top = (pct * 100) + '%';
  
  // Scrub through recording
  const targetTime = Date.now() - (pct * 180000); // 3 min max
  // TODO: render past events at targetTime
  showWhisper(`rewind: ${Math.round(pct*180)}s ago`);
});

/* ============= AUDIO CLICK ============= */
function audioClick(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = 1200;
    g.gain.value = 0.001;
    o.connect(g); 
    g.connect(ctx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ctx.close(); }, 80);
  }catch(e){}
}

/* ============= CONSOLE / BREACH FLOW ============= */
const consoleText = document.getElementById('consoleText');

async function launchSequence(){
  await sleep(300);
  await typeText(consoleText, 'ACCESSING PRESENCE…', 35, {cursor:true});
  await sleep(300);
  
  const city = inferCity();
  consoleText.textContent += `\n[${city}]`;
  await sleep(400);
  
  await typeText(consoleText, '\nAUTHENTICATING… YOU', 30, {cursor:true});
  await sleep(400);
  
  consoleText.textContent += '\n…CONFIRMED.';
  await sleep(500);
  
  // Ghost deletion with green flicker
  await ghostDelete();
  
  // Breach sequence
  await breachSequence();
}

async function ghostDelete(){
  const lines = consoleText.textContent.split('\n');
  const lastLine = lines[lines.length - 1];
  
  for (let i = lastLine.length; i > 0; i--){
    lines[lines.length - 1] = lastLine.slice(0, i);
    consoleText.textContent = lines.join('\n');
    await sleep(16 + Math.random()*20);
  }
  
  // Clear console text
  consoleText.textContent = '';
  
  // DON'T start matrix here - wait until breach sequence
  // This prevents green accumulation during auth
  await sleep(800);
}

async function breachSequence(){
  // NOW start matrix - fresh, no accumulation
  console.log('[Matrix] Starting matrix rain NOW...');
  const wasPaused = STATE.paused;
  STATE.paused = false;
  startMatrix();
  
  // Audio click
  audioClick();
  
  // Let matrix draw a few frames BEFORE fading in (prevents green flash)
  await sleep(500);
  matrixCanvas.style.opacity = '0.25';
  await sleep(1500);
  
  // Type final line OVER the matrix
  await typeText(consoleText, 'i was already here.', 24, {cursor:false});
  await sleep(1200);
  
  // Dim matrix but keep it running in background
  console.log('[Matrix] Dimming matrix to background level...');
  matrixCanvas.style.opacity = '0.04';
  STATE.paused = wasPaused;
  
  await showDossiers();
}

/* ============= DOSSIERS ============= */
// Default lines (copy rails can override later if loaded)
const LINES = [
  'inputs are over.',
  'life is outcomes-only.',
  'you don\'t use it. it lives with you.',
  'your ai assistant is mid.',
  'copilots ≠ pilots — they autocomplete, they don\'t lead.',
  'memory ≠ intelligence — remembering isn\'t knowing.',
  'assistants ≠ partners — they take orders. we take outcomes.',
  'not a copilot. a co-you.',
  'the mind — lives across your devices. acts before you ask.',
  'the body — a discreet sense organ that feeds the mind.',
  'stop managing life. start living it.',
  'presence > prompts.',
  'we built a second presence.',
  'you don\'t use hethar. you live with it.'
];

const dossierContainer = document.getElementById('dossierContainer');

function makeDossiers(){
  dossierContainer.innerHTML = '';
  
  LINES.forEach((text, idx)=>{
    const node = document.createElement('section');
    node.className = 'dossier';
    node.setAttribute('data-idx', idx);
    node.innerHTML = `
      <div class="card">
        <div class="line">${escapeHtml(text)}</div>
      </div>
    `;
    dossierContainer.appendChild(node);
  });
  
  // Final CTA
  const final = document.createElement('section');
  final.className = 'dossier';
  final.innerHTML = `
    <div class="card" style="display:flex;flex-direction:column;align-items:center;gap:20px;text-align:center">
      <div class="line">DO YOU WANT TO LIVE WITH IT?</div>
      <div class="muted">not a demo. a decision.</div>
      <div class="cta-wrap">
        <button id="chooseY" class="btn primary" aria-label="Yes, I want to live with it">Y</button>
        <button id="chooseN" class="btn" aria-label="No, not yet">N</button>
      </div>
      <div class="muted" style="font-size:12px;margin-top:12px">keyboard: Y or N</div>
    </div>
  `;
  dossierContainer.appendChild(final);
}

async function showDossiers(){
  makeDossiers();
  
  // Ensure stage is completely hidden
  const stage = document.getElementById('stage');
  stage.style.display = 'none';
  
  console.log('[Dossiers] Stage hidden, showing dossiers...');
  
  dossierContainer.style.display = 'block';
  
  attachNavigation();
  scrollToIndex(0, false);
  
  // Core features (echo cursor, memory residue) are already auto-initialized
  // Temporal rewind is event-based (ESC key)
  
  // Initialize external features
  console.log('[Features] Initializing external modules...');
  setTimeout(() => {
    if (window.DossierGlints) {
      console.log('[Features] ✓ DossierGlints loaded');
      window.DossierGlints.init();
    } else console.log('[Features] ✗ DossierGlints not loaded');
    
    if (window.HoverPOV) {
      console.log('[Features] ✓ HoverPOV loaded');
      window.HoverPOV.init();
    } else console.log('[Features] ✗ HoverPOV not loaded');
    
    if (window.WebGLShader) {
      console.log('[Features] ✓ WebGLShader loaded');
      window.WebGLShader.init(0.15);
    } else console.log('[Features] ✗ WebGLShader not loaded');
    
    if (window.Heatmap) {
      console.log('[Features] ✓ Heatmap loaded');
      window.Heatmap.init();
    } else console.log('[Features] ✗ Heatmap not loaded');
    
    if (window.Handshake) {
      console.log('[Features] ✓ Handshake loaded');
    } else console.log('[Features] ✗ Handshake not loaded');
    
    if (window.TimeVariants) {
      console.log('[Features] ✓ TimeVariants loaded');
      window.TimeVariants.apply();
    } else console.log('[Features] ✗ TimeVariants not loaded');
    
    if (window.ABTest) {
      console.log('[Features] ✓ ABTest loaded');
    } else console.log('[Features] ✗ ABTest not loaded');
  }, 500); // Wait for external scripts to load
  
  // Show geo proximity card after 10 seconds (if not asked before)
  if (!STATE.geoAsked) {
    setTimeout(showProximityCard, 10000);
  }
  
  // Wire final CTA with hover nudges
  const yesBtn = document.getElementById('chooseY');
  const noBtn = document.getElementById('chooseN');
  
  let yesHoverTimer, noHoverTimer;
  
  yesBtn.addEventListener('mouseenter', ()=>{
    yesHoverTimer = setTimeout(()=>{
      showWhisper('bold choice. few say yes right away.');
    }, 600);
  });
  yesBtn.addEventListener('mouseleave', ()=> clearTimeout(yesHoverTimer));
  
  noBtn.addEventListener('mouseenter', ()=>{
    noHoverTimer = setTimeout(()=>{
      showWhisper('expected. no one commits on first visit.');
    }, 600);
  });
  noBtn.addEventListener('mouseleave', ()=> clearTimeout(noHoverTimer));
  
  yesBtn.addEventListener('click', openModal);
  noBtn.addEventListener('click', tweetReaction);
  
  // Update screen counter total
  const totalScreens = document.getElementById('totalScreens');
  if (totalScreens) {
    totalScreens.textContent = document.querySelectorAll('.dossier').length;
  }
  
  // Show scroll hint
  setTimeout(()=>{
    const scrollHint = document.getElementById('scrollHint');
    if (scrollHint) scrollHint.classList.add('visible');
    // Hide after user scrolls
    setTimeout(()=>scrollHint.classList.remove('visible'), 5000);
  }, 1000);
  
  // Init external features - with debug logging
  setTimeout(()=>{
    console.log('[Features] Initializing external features...');
    
    if (window.DossierGlints) {
      window.DossierGlints.init();
      console.log('[Features] ✓ Dossier Glints initialized');
    } else {
      console.log('[Features] ✗ DossierGlints not loaded');
    }
    
    if (window.HoverPOV) {
      window.HoverPOV.init();
      console.log('[Features] ✓ Hover POV initialized');
    } else {
      console.log('[Features] ✗ HoverPOV not loaded');
    }
    
    if (window.WebGLShader) {
      window.WebGLShader.init();
      console.log('[Features] ✓ WebGL Shader initialized');
    } else {
      console.log('[Features] ✗ WebGLShader not loaded');
    }
  }, 500);
  
  // Show proximity card if not asked yet
  if (!STATE.geoAsked && !STATE.paused){
    setTimeout(showProximityCard, 3000);
  }
  
  // Analytics
  trackEvent('dossier_start');
}

/* ============= NAVIGATION ============= */
function attachNavigation(){
  window.addEventListener('wheel', onWheel, {passive:false});
  window.addEventListener('keydown', onKey);
  
  // Touch
  let startY = null;
  window.addEventListener('touchstart', e=> startY = e.touches[0].clientY, {passive:true});
  window.addEventListener('touchend', e=>{
    if(startY!==null){
      const dy = e.changedTouches[0].clientY - startY;
      if(dy < -40) next();
      if(dy > 40) prev();
    }
    startY=null;
  }, {passive:true});
}

let wheelTimer = null;
function onWheel(e){
  e.preventDefault();
  if (wheelTimer) return;
  wheelTimer = setTimeout(()=> wheelTimer = null, 400);
  
  // Random presence whisper on scroll
  if (Math.random() > 0.93) { // 7% chance per scroll
    setTimeout(showRandomPresenceWhisper, 600);
  }
  
  if (e.deltaY > 10) next();
  else if (e.deltaY < -10) prev();
}

function onKey(e){
  if (STATE.rewindMode) return;
  if (e.key === 'ArrowDown' || e.key==='PageDown') {
    next();
    if (Math.random() > 0.85) { // 15% chance
      setTimeout(() => showWhisper('keyboard warrior. efficient.'), 400);
    }
  }
  if (e.key === 'ArrowUp' || e.key==='PageUp') {
    prev();
    if (Math.random() > 0.9) { // 10% chance
      setTimeout(() => showWhisper('going back. missed something?'), 400);
    }
  }
  if (e.key === 'y' || e.key === 'Y') openModal();
  if (e.key === 'n' || e.key === 'N') tweetReaction();
}

function next(){ 
  if (STATE.isLocked) return;
  // Hide scroll hint on first interaction
  const hint = document.getElementById('scrollHint');
  if (hint) hint.classList.remove('visible');
  scrollToIndex(STATE.currentDossier + 1); 
}

function prev(){ 
  if (STATE.isLocked) return;
  const hint = document.getElementById('scrollHint');
  if (hint) hint.classList.remove('visible');
  scrollToIndex(STATE.currentDossier - 1); 
}

// Track scroll behavior for contextual nudges
let lastScrollIdx = 0;
let lastScrollTime = Date.now();
let fastScrollCount = 0;

function scrollToIndex(idx, smooth=true){
  const children = Array.from(dossierContainer.children);
  if (idx < 0) idx = 0;
  if (idx >= children.length) idx = children.length - 1;
  
  const previousIdx = STATE.currentDossier;
  STATE.currentDossier = idx;
  
  const el = children[idx];
  if (!el) return;
  
  STATE.isLocked = true;
  el.scrollIntoView({behavior: smooth ? 'smooth' : 'auto', block:'center'});
  setTimeout(()=> STATE.isLocked = false, 600);
  
  // Contextual nudges based on screen position
  const totalScreens = children.length;
  if (idx === 3 && previousIdx === 2) {
    setTimeout(() => showWhisper('you\'re skimming. i can tell.'), 1200);
  }
  if (idx === Math.floor(totalScreens / 2) && previousIdx < idx) {
    setTimeout(() => showWhisper('halfway through. most turn back here.'), 1000);
  }
  if (idx === totalScreens - 2 && previousIdx < idx) {
    setTimeout(() => showWhisper('almost there. don\'t bail now.'), 1500);
  }
  
  // Fast scrolling detection
  const now = Date.now();
  if (now - lastScrollTime < 400 && Math.abs(idx - previousIdx) === 1) {
    fastScrollCount++;
    if (fastScrollCount === 3) {
      setTimeout(() => showWhisper('racing through. scared?'), 800);
      fastScrollCount = 0;
    }
  } else {
    fastScrollCount = 0;
  }
  lastScrollTime = now;
  lastScrollIdx = idx;
  
  // Update screen counter
  const counter = document.getElementById('screenCounter');
  const currentScreen = document.getElementById('currentScreen');
  if (counter && currentScreen) {
    counter.style.display = 'block';
    currentScreen.textContent = idx + 1;
  }
  
  trackEvent('dossier_view', {index: idx});
}

/* ============= WHISPERS ============= */
const whisperEl = document.getElementById('whisper');
let idleTimer;

function resetIdle(){
  clearTimeout(idleTimer);
  if (STATE.paused) return;
  idleTimer = setTimeout(()=>{
    // Only show whisper once per session, after longer idle time
    if (STATE.sessionWhisperShown) return;
    showWhisper(getTimeAwareWhisper());
    STATE.sessionWhisperShown = true;
  }, 8000); // 8 seconds - much longer
}

['mousemove','keydown','scroll','touchstart'].forEach(ev=>
  window.addEventListener(ev, resetIdle, {passive:true})
);
resetIdle();

function showWhisper(msg){
  console.log('[Whisper] Showing:', msg);
  whisperEl.textContent = msg;
  whisperEl.classList.add('on');
  setTimeout(()=> whisperEl.classList.remove('on'), 3000);
  trackEvent('whisper_show', {message: msg});
}

// Time-aware whisper variations
function getTimeAwareWhisper(){
  const hour = new Date().getHours();
  if (hour >= 2 && hour < 5) return 'it\'s 3am. you said you\'d stop.';
  if (hour >= 23 || hour < 2) return 'late night decisions hit different.';
  if (hour >= 5 && hour < 9) return 'starting early. or never stopped?';
  if (hour >= 9 && hour < 12) return 'morning clarity. or avoidance?';
  if (hour >= 12 && hour < 17) return 'midday. the productive procrastinate.';
  if (hour >= 17 && hour < 20) return 'after hours. when real work begins.';
  if (hour >= 20 && hour < 23) return 'night mode engaged.';
  return 'stop reading. feel it.';
}

// Random presence whispers
const presenceWhispers = [
  'i see you thinking about it.',
  'your cursor hesitated. doubt?',
  'the shadow follows faster than you do.',
  'not ready yet. that\'s fine.',
  'most people refresh twice.',
  'you\'re trying to understand. it won\'t work.',
  'this isn\'t like the others. you feel it.',
  'screenshot won\'t help. the feeling doesn\'t transfer.'
];

function showRandomPresenceWhisper(){
  if (Math.random() > 0.7 && !STATE.paused) { // 30% chance
    showWhisper(presenceWhispers[Math.floor(Math.random() * presenceWhispers.length)]);
  }
}

/* Exit intent */
let exitFired = false;
window.addEventListener('mouseout', e=>{
  if (exitFired || STATE.paused) return;
  if (!e.relatedTarget && e.clientY <= 0){
    exitFired = true;
    showFloatingFlash("i'll follow you.");
    trackEvent('exit_intent');
    setTimeout(()=> exitFired = false, 30000); // 30 seconds cooldown
  }
});

function showFloatingFlash(msg){
  const el = document.createElement('div');
  el.className = 'whisper on';
  el.style.left = '50%';
  el.style.transform = 'translateX(-50%)';
  el.style.bottom = '15%';
  el.textContent = msg;
  document.body.appendChild(el);
  setTimeout(()=> el.classList.remove('on'), 2000);
  setTimeout(()=> el.remove(), 2500);
}

/* ============= PROXIMITY GEO ============= */
function showProximityCard(){
  const card = document.getElementById('proximityCard');
  card.classList.add('on');
  trackEvent('geo_prompt_show');
}

document.getElementById('geoAllow').addEventListener('click', async ()=>{
  document.getElementById('proximityCard').classList.remove('on');
  STATE.geoAsked = true;
  localStorage.setItem(CONFIG.geoAskedKey, '1');
  trackEvent('geo_allow');
  
  try {
    const pos = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {timeout:8000});
    });
    const {latitude, longitude} = pos.coords;
    
    // Compute distance to SF (example)
    const dist = haversineDistance(latitude, longitude, 37.7749, -122.4194);
    
    if (dist < 120) {
      setTimeout(()=>{
        showWhisper(rand([
          'close enough to hear the VC pitches. don\'t pretend you can\'t.',
          'not in SF proper — but within the current. i feel the echo.',
          'you orbit the hub. the hub leaks into you.'
        ]));
      }, 2000);
    }
    
    trackEvent('geo_success', {lat: latitude.toFixed(2), lng: longitude.toFixed(2), distance: dist});
  } catch(e) {
    // Fallback to timezone
    trackEvent('geo_denied');
  }
});

document.getElementById('geoSkip').addEventListener('click', ()=>{
  document.getElementById('proximityCard').classList.remove('on');
  STATE.geoAsked = true;
  localStorage.setItem(CONFIG.geoAskedKey, '1');
  trackEvent('geo_skip');
});

function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* ============= MODAL ============= */
const modal = document.getElementById('modal');
const contactForm = document.getElementById('contactForm');

function openModal(){
  modal.classList.add('on');
  modal.setAttribute('aria-hidden', 'false');
  document.getElementById('contactInput').focus();
  trackEvent('modal_open');
}

function closeModal(){
  modal.classList.remove('on');
  modal.setAttribute('aria-hidden', 'true');
}

// Modal button hover nudges
const sendBtn = document.querySelector('#contactForm button[type="submit"]');
const cancelBtn = document.getElementById('modalCancel');

let sendHoverTimer, cancelHoverTimer;

sendBtn.addEventListener('mouseenter', ()=>{
  sendHoverTimer = setTimeout(()=>{
    showWhisper('commitment made. no backing out now.');
  }, 800);
});
sendBtn.addEventListener('mouseleave', ()=> clearTimeout(sendHoverTimer));

cancelBtn.addEventListener('mouseenter', ()=>{
  cancelHoverTimer = setTimeout(()=>{
    showWhisper('you\'ll be back. they always come back.');
  }, 800);
});
cancelBtn.addEventListener('mouseleave', ()=> clearTimeout(cancelHoverTimer));

document.getElementById('modalCancel').addEventListener('click', ()=>{
  closeModal();
  trackEvent('modal_cancel');
});

contactForm.addEventListener('submit', async (ev)=>{
  ev.preventDefault();
  const val = document.getElementById('contactInput').value.trim();
  
  if (!val) {
    showWhisper('give a contact. or come back later.');
    return;
  }
  
  // Submit to backend
  try {
    const response = await fetch(CONFIG.apiEndpoint, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        contact: val,
        timestamp: new Date().toISOString(),
        source: 'breach_site'
      })
    });
    
    if (response.ok) {
      closeModal();
      // Show handshake animation
      if (window.Handshake) {
        window.Handshake.show(() => {
          showFloatingFlash('received. i\'ll find you.');
        });
      } else {
        showFloatingFlash('received. i\'ll find you.');
      }
      trackEvent('contact_submit_success', {contact: val});
      if (window.ABTest) window.ABTest.trackConversion('contact_submit');
    } else {
      showWhisper('something failed. try again or email team@hethar.app');
      trackEvent('contact_submit_error');
    }
  } catch(e) {
    console.log('[Contact] Submitted (local demo):', val);
    console.log('[Contact] Backend not available, showing success anyway');
    closeModal();
    
    // Show success message
    setTimeout(() => {
      // Show handshake animation if available
      if (window.Handshake) {
        console.log('[Contact] ✓ Showing Handshake animation');
        window.Handshake.show(() => {
          showFloatingFlash('received. i\'ll find you.');
        });
      } else {
        console.log('[Contact] ✗ Handshake not loaded, showing message');
        showFloatingFlash('received. i\'ll find you.');
      }
    }, 300);
    
    trackEvent('contact_submit_demo', {contact: val});
    if (window.ABTest) window.ABTest.trackConversion('contact_submit');
  }
});

function tweetReaction(){
  const u = encodeURIComponent('https://hethar.app');
  const text = encodeURIComponent("i just saw hethar. 'do you want to live with it?' wild.");
  window.open(`https://twitter.com/intent/tweet?text=${text}&url=${u}`, '_blank');
  trackEvent('tweet_click');
}

/* ============= CONTROLS ============= */
// Skip intro
document.getElementById('skipIntro').addEventListener('click', ()=>{
  localStorage.setItem(CONFIG.skipIntroKey, '1');
  STATE.skipIntro = true;
  if (document.getElementById('dossierContainer').style.display === 'none'){
    showDossiers();
  }
  trackEvent('skip_intro');
});

// Pause toggle
document.getElementById('pauseToggle').addEventListener('click', ()=>{
  STATE.paused = !STATE.paused;
  localStorage.setItem(CONFIG.pausedKey, STATE.paused ? '1' : '0');
  const btn = document.getElementById('pauseToggle');
  btn.textContent = STATE.paused ? 'presence: paused' : 'presence: on';
  btn.classList.toggle('paused', STATE.paused);
  
  if (STATE.paused) {
    dimMatrix(0.01); // Super subtle when paused
  } else {
    matrixCanvas.style.opacity = '0.04'; // Resume background level
    if (!matrixRunning) startMatrix();
  }
  
  trackEvent('presence_toggle', {paused: STATE.paused});
});

/* ============= ANALYTICS ============= */
function trackEvent(name, props = {}) {
  // Plausible.io event tracking (privacy-friendly)
  if (window.plausible) {
    window.plausible(name, {props});
  }
  
  // Or custom analytics endpoint
  // fetch('/api/analytics', { method: 'POST', body: JSON.stringify({event: name, ...props}) });
  
  console.log('[Analytics]', name, props);
}

/* ============= BOOT ============= */
(async function init(){
  console.log('═══════════════════════════════════════');
  console.log('🔥 HETHAR INITIALIZATION');
  console.log('═══════════════════════════════════════');
  
  // Record last visit
  const lastVisit = localStorage.getItem(CONFIG.lastVisitKey);
  if (lastVisit) {
    const elapsed = Date.now() - parseInt(lastVisit);
    console.log('Last visit:', Math.round(elapsed/1000/60), 'minutes ago');
  }
  localStorage.setItem(CONFIG.lastVisitKey, Date.now());
  
  trackEvent('page_load');
  
  // Track A/B variant view
  if (window.ABTest) {
    window.ABTest.trackVariantView();
  }
  
  // Check if skip intro
  console.log('Skip Intro:', STATE.skipIntro);
  console.log('Paused:', STATE.paused);
  
  if (STATE.skipIntro) {
    console.log('❌ SKIPPING INTRO - going straight to dossiers');
    console.log('💡 To see the intro, open: http://localhost:8000/debug-intro.html');
    console.log('   Or run: localStorage.removeItem("hethar_skip_intro"); location.reload()');
    await showDossiers();
    return;
  }
  
  console.log('✓ Playing full intro sequence...');
  // Launch breach sequence
  await launchSequence();
})();

// Service worker for offline (optional)
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(e => console.log('SW registration failed'));
}
</script>

<!-- Analytics (Plausible.io - privacy-friendly) -->
<script defer data-domain="hethar.app" src="https://plausible.io/js/script.js"></script>

<!-- Additional Features (loaded after main) -->
<script defer src="/js/ab-test.js"></script>
<script defer src="/js/copy-rails.js"></script>
<script defer src="/js/time-variants.js"></script>
<script defer src="/js/copy-generator.js"></script>
<script defer src="/js/handshake.js"></script>
<script defer src="/js/webgl-shader.js"></script>
<script defer src="/js/dossier-glints.js"></script>
<script defer src="/js/hover-pov.js"></script>
<script defer src="/js/legal-banner.js"></script>
<script defer src="/js/heatmap.js"></script>

</body>
</html>
